name: dependency-update
description: Automated dependency updates across repositories
version: "1.0"

# Workflow metadata
metadata:
  author: ghops
  tags: [maintenance, dependencies, security]
  schedule: "0 0 * * MON"  # Weekly on Monday
  required_tools:
    - pip-tools
    - npm-check-updates
    - cargo-edit

# Parameters
parameters:
  update_strategy:
    type: string
    default: conservative
    choices: [conservative, moderate, aggressive]
    description: How aggressively to update dependencies
  create_prs:
    type: boolean
    default: true
    description: Create pull requests for updates
  group_updates:
    type: boolean
    default: true
    description: Group related updates together

# Global context
context:
  max_pr_per_repo: 3
  test_before_commit: true
  update_strategy: "${update_strategy}"

# Task definitions
tasks:
  # Stage 1: Discovery
  - id: find-repos
    name: Find repositories with dependencies
    type: ghops
    command: query
    args: |
      "package.type in ['python', 'javascript', 'rust'] or
       'requirements.txt' in files or
       'package.json' in files or
       'Cargo.toml' in files"
    parse_output: true
    output_var: repos_with_deps

  - id: analyze-dependencies
    name: Analyze current dependencies
    type: parallel
    depends_on: find-repos
    tasks:
      - type: python
        name: Analyze Python dependencies
        code: |
          import json
          python_repos = []
          for repo in context.get('repos_with_deps', []):
            if repo.get('package', {}).get('type') == 'python':
              python_repos.append(repo['path'])
          context['python_repos'] = python_repos

      - type: python
        name: Analyze JavaScript dependencies
        code: |
          import json
          js_repos = []
          for repo in context.get('repos_with_deps', []):
            if repo.get('package', {}).get('type') == 'javascript':
              js_repos.append(repo['path'])
          context['js_repos'] = js_repos

      - type: python
        name: Analyze Rust dependencies
        code: |
          import json
          rust_repos = []
          for repo in context.get('repos_with_deps', []):
            if any('Cargo.toml' in f for f in repo.get('files', [])):
              rust_repos.append(repo['path'])
          context['rust_repos'] = rust_repos

  # Stage 2: Security scanning
  - id: check-vulnerabilities
    name: Scan for known vulnerabilities
    type: parallel
    depends_on: analyze-dependencies
    tasks:
      - type: shell
        name: Python security scan
        command: |
          for repo in ${python_repos}; do
            cd "$repo"
            if [ -f requirements.txt ]; then
              pip-audit --desc || echo "Vulnerabilities found in $repo"
            fi
          done
        output_var: python_vulns
        ignore_errors: true

      - type: shell
        name: JavaScript security scan
        command: |
          for repo in ${js_repos}; do
            cd "$repo"
            if [ -f package.json ]; then
              npm audit --json || echo "Vulnerabilities found in $repo"
            fi
          done
        output_var: js_vulns
        ignore_errors: true

  - id: prioritize-security
    name: Prioritize security updates
    type: python
    depends_on: check-vulnerabilities
    code: |
      # Parse vulnerability reports and create priority list
      security_updates = []

      # Process Python vulnerabilities
      if context.get('python_vulns'):
        # Parse and prioritize critical/high severity
        pass

      # Process JavaScript vulnerabilities
      if context.get('js_vulns'):
        # Parse npm audit output
        pass

      context['security_priority'] = security_updates
      context['has_security_issues'] = len(security_updates) > 0

  # Stage 3: Update Python dependencies
  - id: update-python-deps
    name: Update Python dependencies
    type: shell
    depends_on: prioritize-security
    condition: python_repos
    command: |
      strategy="${update_strategy}"

      for repo in ${python_repos}; do
        cd "$repo"
        branch_name="deps/python-update-$(date +%Y%m%d)"

        # Create update branch
        git checkout -b "$branch_name"

        # Update based on strategy
        if [ -f requirements.in ]; then
          case "$strategy" in
            conservative)
              # Only security updates
              pip-compile --upgrade-package pip-audit-reported-packages
              ;;
            moderate)
              # Minor and patch updates
              pip-compile --upgrade
              ;;
            aggressive)
              # All updates including major versions
              pip-compile --upgrade --rebuild
              ;;
          esac
        elif [ -f requirements.txt ]; then
          # Direct requirements.txt update
          pip list --outdated --format json > outdated.json
          python -c "
import json
with open('outdated.json') as f:
    outdated = json.load(f)
for pkg in outdated:
    if '${strategy}' == 'conservative' and not pkg.get('vulnerability'):
        continue
    print(f\"{pkg['name']}=={pkg['latest_version']}\")
" > requirements.new.txt
          mv requirements.new.txt requirements.txt
        fi

        # Store update info
        echo "$repo:$branch_name" >> /tmp/python_updates.txt
      done
    output_var: python_update_branches

  # Stage 4: Update JavaScript dependencies
  - id: update-js-deps
    name: Update JavaScript dependencies
    type: shell
    depends_on: prioritize-security
    condition: js_repos
    command: |
      strategy="${update_strategy}"

      for repo in ${js_repos}; do
        cd "$repo"
        branch_name="deps/js-update-$(date +%Y%m%d)"

        # Create update branch
        git checkout -b "$branch_name"

        # Update based on strategy
        case "$strategy" in
          conservative)
            # Only security updates
            npm audit fix
            ;;
          moderate)
            # Minor and patch updates
            npx npm-check-updates -u --target minor
            npm install
            ;;
          aggressive)
            # All updates including major versions
            npx npm-check-updates -u
            npm install
            ;;
        esac

        # Update lockfile
        npm install

        # Store update info
        echo "$repo:$branch_name" >> /tmp/js_updates.txt
      done
    output_var: js_update_branches

  # Stage 5: Update Rust dependencies
  - id: update-rust-deps
    name: Update Rust dependencies
    type: shell
    depends_on: prioritize-security
    condition: rust_repos
    command: |
      strategy="${update_strategy}"

      for repo in ${rust_repos}; do
        cd "$repo"
        branch_name="deps/rust-update-$(date +%Y%m%d)"

        # Create update branch
        git checkout -b "$branch_name"

        # Update based on strategy
        case "$strategy" in
          conservative)
            # Only security updates
            cargo audit fix
            ;;
          moderate)
            # Compatible updates
            cargo update
            ;;
          aggressive)
            # All updates including breaking changes
            cargo upgrade --incompatible
            cargo update
            ;;
        esac

        # Store update info
        echo "$repo:$branch_name" >> /tmp/rust_updates.txt
      done
    output_var: rust_update_branches

  # Stage 6: Testing updates
  - id: test-updates
    name: Run tests on updated dependencies
    type: parallel
    depends_on: [update-python-deps, update-js-deps, update-rust-deps]
    condition: test_before_commit
    tasks:
      - type: shell
        name: Test Python updates
        command: |
          while IFS=: read -r repo branch; do
            cd "$repo"
            git checkout "$branch"

            # Run tests
            if [ -f pytest.ini ] || [ -f setup.cfg ] || [ -f pyproject.toml ]; then
              pytest || echo "FAILED:$repo" >> /tmp/test_failures.txt
            elif [ -f manage.py ]; then
              python manage.py test || echo "FAILED:$repo" >> /tmp/test_failures.txt
            else
              python -m unittest discover || echo "FAILED:$repo" >> /tmp/test_failures.txt
            fi
          done < /tmp/python_updates.txt
        ignore_errors: true

      - type: shell
        name: Test JavaScript updates
        command: |
          while IFS=: read -r repo branch; do
            cd "$repo"
            git checkout "$branch"

            # Run tests
            npm test || echo "FAILED:$repo" >> /tmp/test_failures.txt
          done < /tmp/js_updates.txt
        ignore_errors: true

      - type: shell
        name: Test Rust updates
        command: |
          while IFS=: read -r repo branch; do
            cd "$repo"
            git checkout "$branch"

            # Run tests
            cargo test || echo "FAILED:$repo" >> /tmp/test_failures.txt
          done < /tmp/rust_updates.txt
        ignore_errors: true

  # Stage 7: Commit and create PRs
  - id: commit-updates
    name: Commit dependency updates
    type: shell
    depends_on: test-updates
    command: |
      # Process all update branches
      for update_file in /tmp/*_updates.txt; do
        [ -f "$update_file" ] || continue

        while IFS=: read -r repo branch; do
          cd "$repo"

          # Skip if tests failed
          if grep -q "FAILED:$repo" /tmp/test_failures.txt 2>/dev/null; then
            echo "Skipping $repo due to test failures"
            git checkout main
            git branch -D "$branch"
            continue
          fi

          # Commit changes
          git add -A

          # Generate commit message
          commit_msg="chore(deps): Update dependencies

Strategy: ${update_strategy}
"

          # Add details about updates
          if [ -f package.json ]; then
            npm list --depth=0 --json | jq '.dependencies | keys' > /tmp/deps.json
            commit_msg="$commit_msg
Updated npm packages:
$(git diff --name-only | grep -E 'package(-lock)?.json')"
          fi

          if [ -f requirements.txt ]; then
            commit_msg="$commit_msg
Updated Python packages:
$(git diff requirements.txt | grep '^+' | grep -v '^+++' | head -10)"
          fi

          if [ -f Cargo.toml ]; then
            commit_msg="$commit_msg
Updated Rust crates:
$(git diff Cargo.toml | grep '^+' | grep -v '^+++' | head -10)"
          fi

          git commit -m "$commit_msg" || true
        done < "$update_file"
      done

  - id: create-pull-requests
    name: Create pull requests
    type: shell
    depends_on: commit-updates
    condition: create_prs
    command: |
      pr_count=0

      for update_file in /tmp/*_updates.txt; do
        [ -f "$update_file" ] || continue

        while IFS=: read -r repo branch; do
          cd "$repo"

          # Check if branch has commits
          if ! git diff --quiet main.."$branch"; then
            # Push branch
            git push -u origin "$branch"

            # Create PR
            pr_body="## Dependency Updates

**Update Strategy:** ${update_strategy}

### Changes
$(git diff --stat main.."$branch")

### Testing
- [ ] All tests pass
- [ ] Application starts correctly
- [ ] No breaking changes identified

### Security
$(if [ "${has_security_issues}" = "true" ]; then
  echo "This update includes security fixes."
else
  echo "No known security issues addressed."
fi)

---
*Generated by ghops dependency update workflow*"

            gh pr create \
              --title "chore(deps): Update dependencies" \
              --body "$pr_body" \
              --base main \
              --head "$branch" \
              --label "dependencies" \
              --label "automated"

            pr_count=$((pr_count + 1))

            # Limit PRs per repo
            repo_pr_count=$(gh pr list --repo "$repo" --author @me --state open | wc -l)
            if [ "$repo_pr_count" -ge "${max_pr_per_repo}" ]; then
              echo "Max PRs reached for $repo"
              break
            fi
          fi
        done < "$update_file"
      done

      echo "Created $pr_count pull requests"

  # Stage 8: Reporting
  - id: generate-report
    name: Generate dependency update report
    type: python
    depends_on: create-pull-requests
    code: |
      import datetime
      import json

      report = {
        'date': datetime.datetime.now().isoformat(),
        'strategy': context['update_strategy'],
        'repositories_scanned': len(context.get('repos_with_deps', [])),
        'python_repos_updated': len(context.get('python_repos', [])),
        'js_repos_updated': len(context.get('js_repos', [])),
        'rust_repos_updated': len(context.get('rust_repos', [])),
        'security_issues_found': context.get('has_security_issues', False),
        'pull_requests_created': context.get('create_prs', False),
      }

      print("=" * 60)
      print("DEPENDENCY UPDATE REPORT")
      print("=" * 60)
      for key, value in report.items():
        print(f"{key.replace('_', ' ').title()}: {value}")
      print("=" * 60)

      # Save report
      with open('/tmp/dependency_report.json', 'w') as f:
        json.dump(report, f, indent=2)

      context['report'] = report

# Workflow hooks
hooks:
  on_start:
    - type: shell
      command: |
        echo "Starting dependency update workflow"
        echo "Strategy: ${update_strategy}"
        echo "Create PRs: ${create_prs}"

  on_success:
    - type: shell
      command: |
        echo "Dependency updates completed successfully"
        if [ -f /tmp/dependency_report.json ]; then
          cat /tmp/dependency_report.json
        fi

  on_failure:
    - type: shell
      command: |
        echo "Dependency update workflow failed"
        # Clean up any created branches
        for update_file in /tmp/*_updates.txt; do
          [ -f "$update_file" ] || continue
          while IFS=: read -r repo branch; do
            cd "$repo" && git checkout main && git branch -D "$branch" 2>/dev/null || true
          done < "$update_file"
        done